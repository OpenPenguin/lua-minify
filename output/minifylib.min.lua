local k={}do function a(R)for S,T in pairs(R)do R[T]=true end return R end function b(R)local S=0 for T in pairs(R)do S=S+1 end return S end function c(R,S,T)if R.Print then return R.Print()end S=S or 0 local U=(b(R)>1)local V=string.rep('    ',S+1)local W="{"..(U and'\n'or'')for X,Y in pairs(R)do if type(Y)~='function'and not T(X)then W=W..(U and V or'')if type(X)=='number'then elseif type(X)=='string'and X:match("^[A-Za-z_][A-Za-z0-9_]*$")then W=W..X.." = "elseif type(X)=='string'then W=W.."[\""..X.."\"] = "else W=W.."["..tostring(X).."] = "end if type(Y)=='string'then W=W.."\""..Y.."\""elseif type(Y)=='number'then W=W..Y elseif type(Y)=='table'then W=W..c(Y,S+(U and 1 or 0),T)else W=W..tostring(Y)end if next(R,X)then W=W..","end if U then W=W..'\n'end end end W=W..(U and string.rep('    ',S)or'').."}"return W end function d(R,S)S=S or function()return false end return c(R,0,S)end local p=a{' ','\n','\t','\r'}local q={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'",['\\']='\\'}local r={['r']='\r',['n']='\n',['t']='\t',['"']='"',["'"]="'",['\\']='\\'}local s=a{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_'}local t=a{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','0','1','2','3','4','5','6','7','8','9'}local u=a{'0','1','2','3','4','5','6','7','8','9'}local v=a{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}local w=a{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#','.',':'}local x=a{'~','=','>','<'}local y=a{'and','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while',}local z=a{'else','elseif','until','end'}local A=a{'-','not','#'}local B=a{'+','-','*','/','%','^','#','..','.',':','>','<','<=','>=','~=','==','and','or'}local C=a{}local D={['+']={6,6};['-']={6,6};['*']={7,7};['/']={7,7};['%']={7,7};['^']={10,9};['..']={5,4};['==']={3,3};['~=']={3,3};['>']={3,3};['<']={3,3};['>=']={3,3};['<=']={3,3};['and']={2,2};['or']={1,1};}local E=8 function e(R)local S=1 local T=#R local U={}local function V(eb)eb=S+(eb or 0)if eb<=T then return R:sub(eb,eb)else return''end end local function W()if S<=T then local eb=R:sub(S,S)S=S+1 return eb else return''end end local X=error local function Y(eb)local fb=1 local gb=1 local hb=1 while fb<=S do if R:sub(fb,fb)=='\n'then gb=gb+1 hb=1 else hb=hb+1 end fb=fb+1 end for ib,jb in pairs(U)do print(jb.Type.."<"..jb.Source..">")end X("file<"..gb..":"..hb..">: "..eb)end local function Z(eb)while true do local fb=W()if fb==''then Y("Unfinished long string.")elseif fb==']'then local gb=true for hb=1,eb do if V()=='='then S=S+1 else gb=false break end end if gb and W()==']'then return end end end end local function ab()local eb=S while V()=='='do S=S+1 end if V()=='['then S=S+1 return S-eb-1 else S=eb return nil end end local bb=1 local cb=1 local function db(eb)local fb={Type=eb;LeadingWhite=R:sub(bb,cb-1);Source=R:sub(cb,S-1);}table.insert(U,fb)bb=S cb=S return fb end while true do bb=S while true do local gb=V()if gb==''then break elseif gb=='-'then if V(1)=='-'then S=S+2 if V()=='['then S=S+1 local hb=ab()if hb then Z(hb)else while true do local ib=W()if ib==''or ib=='\n'then break end end end else while true do local hb=W()if hb==''or hb=='\n'then break end end end else break end elseif p[gb]then S=S+1 else break end end local eb=R:sub(bb,S-1)cb=S local fb=W()if fb==''then db('Eof')break elseif fb=='\''or fb=='\"'then while true do local gb=W()if gb=='\\'then local hb=W()local ib=r[hb]if not ib then Y("Invalid Escape Sequence `"..hb.."`.")end elseif gb==fb then break end end db('String')elseif s[fb]then while t[V()]do S=S+1 end if y[R:sub(cb,S-1)]then db('Keyword')else db('Ident')end elseif u[fb]or(fb=='.'and u[V()])then if fb=='0'and V()=='x'then S=S+1 while v[V()]do S=S+1 end else while u[V()]do S=S+1 end if V()=='.'then S=S+1 while u[V()]do S=S+1 end end if V()=='e'or V()=='E'then S=S+1 if V()=='-'then S=S+1 end while u[V()]do S=S+1 end end end db('Number')elseif fb=='['then local gb=ab()if gb then Z(gb)db('String')else db('Symbol')end elseif fb=='.'then if V()=='.'then W()if V()=='.'then W()end end db('Symbol')elseif x[fb]then if V()=='='then S=S+1 end db('Symbol')elseif w[fb]then db('Symbol')else Y("Bad symbol `"..fb.."` in source.")end end return U end function f(R)local S=e(R)local T=1 local function U()local yb=S[T]if T<#S then T=T+1 end return yb end local function V(yb)yb=T+(yb or 0)return S[yb]or S[#S]end local function W(yb)local zb=1 local Ab=0 local Bb=1 while true do local Cb=S[Bb]local Db if Cb==yb then Db=Cb.LeadingWhite else Db=Cb.LeadingWhite..Cb.Source end for Eb=1,#Db do local Fb=Db:sub(Eb,Eb)if Fb=='\n'then zb=zb+1 Ab=0 else Ab=Ab+1 end end if Cb==yb then break end Bb=Bb+1 end return zb..":"..(Ab+1)end local function X()local yb=V()return"<"..yb.Type.." `"..yb.Source.."`> at: "..W(yb)end local function Y()local yb=V()return yb.Type=='Eof'or(yb.Type=='Keyword'and z[yb.Source])end local function Z()return A[V().Source]or false end local function ab()return B[V().Source]or false end local function bb(yb,zb)local Ab=V()if Ab.Type==yb and(zb==nil or Ab.Source==zb)then return U()else for Bb=-3,3 do print("Tokens["..Bb.."] = `"..V(Bb).Source.."`")end if zb then error(W(Ab)..": `"..zb.."` expected.")else error(W(Ab)..": "..yb.." expected.")end end end local function cb(yb)local zb=yb.GetFirstToken local Ab=yb.GetLastToken function yb:GetFirstToken()local Bb=zb(self)assert(Bb)return Bb end function yb:GetLastToken()local Bb=Ab(self)assert(Bb)return Bb end return yb end local db local eb local function fb()local yb={}local zb={}table.insert(yb,eb())while V().Source==','do table.insert(zb,U())table.insert(yb,eb())end return yb,zb end local function gb()local yb=V()if yb.Source=='('then local zb=U()local Ab=eb()local Bb=bb('Symbol',')')return cb{Type='ParenExpr';Expression=Ab;Token_OpenParen=zb;Token_CloseParen=Bb;GetFirstToken=function(Cb)return Cb.Token_OpenParen end;GetLastToken=function(Cb)return Cb.Token_CloseParen end;}elseif yb.Type=='Ident'then return cb{Type='VariableExpr';Token=U();GetFirstToken=function(zb)return zb.Token end;GetLastToken=function(zb)return zb.Token end;}else print(X())error(W(yb)..": Unexpected symbol")end end function g()local yb=bb('Symbol','{')local zb={}local Ab={}while V().Source~='}'do if V().Source=='['then local Cb=U()local Db=eb()local Eb=bb('Symbol',']')local Fb=bb('Symbol','=')local Gb=eb()table.insert(zb,{EntryType='Index';Index=Db;Value=Gb;Token_OpenBracket=Cb;Token_CloseBracket=Eb;Token_Equals=Fb;})elseif V().Type=='Ident'and V(1).Source=='='then local Cb=U()local Db=U()local Eb=eb()table.insert(zb,{EntryType='Field';Field=Cb;Value=Eb;Token_Equals=Db;})else local Cb=eb()table.insert(zb,{EntryType='Value';Value=Cb;})end if V().Source==','or V().Source==';'then table.insert(Ab,U())else break end end local Bb=bb('Symbol','}')return cb{Type='TableLiteral';EntryList=zb;Token_SeparatorList=Ab;Token_OpenBrace=yb;Token_CloseBrace=Bb;GetFirstToken=function(Cb)return Cb.Token_OpenBrace end;GetLastToken=function(Cb)return Cb.Token_CloseBrace end;}end local function hb()local yb={}local zb={}if V().Type=='Ident'then table.insert(yb,U())end while V().Source==','do table.insert(zb,U())local Ab=bb('Ident')table.insert(yb,Ab)end return yb,zb end local function ib(yb)local zb=db()local Ab=V()if Ab.Type=='Keyword'and Ab.Source==yb then U()return zb,Ab else print(Ab.Type,Ab.Source)error(W(Ab)..": "..yb.." expected.")end end local function jb(yb)local zb=U()local Ab local Bb if not yb then Ab={}Bb={}table.insert(Ab,bb('Ident'))while V().Source=='.'do table.insert(Bb,U())table.insert(Ab,bb('Ident'))end if V().Source==':'then table.insert(Bb,U())table.insert(Ab,bb('Ident'))end end local Cb=bb('Symbol','(')local Db,Eb=hb()local Fb=bb('Symbol',')')local Gb,Hb=ib('end')return cb{Type=(yb and'FunctionLiteral'or'FunctionStat');NameChain=Ab;ArgList=Db;Body=Gb;Token_Function=zb;Token_NameChainSeparator=Bb;Token_OpenParen=Cb;Token_ArgCommaList=Eb;Token_CloseParen=Fb;Token_End=Hb;GetFirstToken=function(Ib)return Ib.Token_Function end;GetLastToken=function(Ib)return Ib.Token_End end;}end local function kb()local yb=V()if yb.Source=='('then local zb=U()local Ab={}local Bb={}while V().Source~=')'do table.insert(Ab,eb())if V().Source==','then table.insert(Bb,U())else break end end local Cb=bb('Symbol',')')return cb{CallType='ArgCall';ArgList=Ab;Token_CommaList=Bb;Token_OpenParen=zb;Token_CloseParen=Cb;GetFirstToken=function(Db)return Db.Token_OpenParen end;GetLastToken=function(Db)return Db.Token_CloseParen end;}elseif yb.Source=='{'then return cb{CallType='TableCall';TableExpr=eb();GetFirstToken=function(zb)return zb.TableExpr:GetFirstToken()end;GetLastToken=function(zb)return zb.TableExpr:GetLastToken()end;}elseif yb.Type=='String'then return cb{CallType='StringCall';Token=U();GetFirstToken=function(zb)return zb.Token end;GetLastToken=function(zb)return zb.Token end;}else error("Function arguments expected.")end end local function lb()local yb=gb()assert(yb,"nil prefixexpr")while true do local zb=V()if zb.Source=='.'then local Ab=U()local Bb=bb('Ident')yb=cb{Type='FieldExpr';Base=yb;Field=Bb;Token_Dot=Ab;GetFirstToken=function(Cb)return Cb.Base:GetFirstToken()end;GetLastToken=function(Cb)return Cb.Field end;}elseif zb.Source==':'then local Ab=U()local Bb=bb('Ident')local Cb=kb()yb=cb{Type='MethodExpr';Base=yb;Method=Bb;FunctionArguments=Cb;Token_Colon=Ab;GetFirstToken=function(Db)return Db.Base:GetFirstToken()end;GetLastToken=function(Db)return Db.FunctionArguments:GetLastToken()end;}elseif zb.Source=='['then local Ab=U()local Bb=eb()local Cb=bb('Symbol',']')yb=cb{Type='IndexExpr';Base=yb;Index=Bb;Token_OpenBracket=Ab;Token_CloseBracket=Cb;GetFirstToken=function(Db)return Db.Base:GetFirstToken()end;GetLastToken=function(Db)return Db.Token_CloseBracket end;}elseif zb.Source=='{'then yb=cb{Type='CallExpr';Base=yb;FunctionArguments=kb();GetFirstToken=function(Ab)return Ab.Base:GetFirstToken()end;GetLastToken=function(Ab)return Ab.FunctionArguments:GetLastToken()end;}elseif zb.Source=='('then yb=cb{Type='CallExpr';Base=yb;FunctionArguments=kb();GetFirstToken=function(Ab)return Ab.Base:GetFirstToken()end;GetLastToken=function(Ab)return Ab.FunctionArguments:GetLastToken()end;}else return yb end end end local function mb()local yb=V()if yb.Type=='Number'then return cb{Type='NumberLiteral';Token=U();GetFirstToken=function(zb)return zb.Token end;GetLastToken=function(zb)return zb.Token end;}elseif yb.Type=='String'then return cb{Type='StringLiteral';Token=U();GetFirstToken=function(zb)return zb.Token end;GetLastToken=function(zb)return zb.Token end;}elseif yb.Source=='nil'then return cb{Type='NilLiteral';Token=U();GetFirstToken=function(zb)return zb.Token end;GetLastToken=function(zb)return zb.Token end;}elseif yb.Source=='true'or yb.Source=='false'then return cb{Type='BooleanLiteral';Token=U();GetFirstToken=function(zb)return zb.Token end;GetLastToken=function(zb)return zb.Token end;}elseif yb.Source=='...'then return cb{Type='VargLiteral';Token=U();GetFirstToken=function(zb)return zb.Token end;GetLastToken=function(zb)return zb.Token end;}elseif yb.Source=='{'then return g()elseif yb.Source=='function'then return jb(true)else return lb()end end local function nb(yb)local zb if Z()then local Ab=U()local Bb=nb(E)zb=cb{Type='UnopExpr';Token_Op=Ab;Rhs=Bb;GetFirstToken=function(Cb)return Cb.Token_Op end;GetLastToken=function(Cb)return Cb.Rhs:GetLastToken()end;}else zb=mb()assert(zb,"nil simpleexpr")end while ab()and D[V().Source][1]>yb do local Ab=U()local Bb=nb(D[Ab.Source][2])assert(Bb,"RhsNeeded")zb=cb{Type='BinopExpr';Lhs=zb;Rhs=Bb;Token_Op=Ab;GetFirstToken=function(Cb)return Cb.Lhs:GetFirstToken()end;GetLastToken=function(Cb)return Cb.Rhs:GetLastToken()end;}end return zb end eb=function()return nb(0)end local function ob()local yb=lb()if yb.Type=='MethodExpr'or yb.Type=='CallExpr'then return cb{Type='CallExprStat';Expression=yb;GetFirstToken=function(zb)return zb.Expression:GetFirstToken()end;GetLastToken=function(zb)return zb.Expression:GetLastToken()end;}else local zb={yb}local Ab={}while V().Source==','do table.insert(Ab,U())local Eb=lb()if Eb.Type=='MethodExpr'or Eb.Type=='CallExpr'then error("Bad left hand side of assignment")end table.insert(zb,Eb)end local Bb=bb('Symbol','=')local Cb={eb()}local Db={}while V().Source==','do table.insert(Db,U())table.insert(Cb,eb())end return cb{Type='AssignmentStat';Rhs=Cb;Lhs=zb;Token_Equals=Bb;Token_LhsSeparatorList=Ab;Token_RhsSeparatorList=Db;GetFirstToken=function(Eb)return Eb.Lhs[1]:GetFirstToken()end;GetLastToken=function(Eb)return Eb.Rhs[#Eb.Rhs]:GetLastToken()end;}end end local function pb()local yb=U()local zb=eb()local Ab=bb('Keyword','then')local Bb=db()local Cb={}while V().Source=='elseif'or V().Source=='else'do local Eb=U()local Fb,Gb if Eb.Source=='elseif'then Fb=eb()Gb=bb('Keyword','then')end local Hb=db()table.insert(Cb,{Condition=Fb;Body=Hb;ClauseType=Eb.Source;Token=Eb;Token_Then=Gb;})if Eb.Source=='else'then break end end local Db=bb('Keyword','end')return cb{Type='IfStat';Condition=zb;Body=Bb;ElseClauseList=Cb;Token_If=yb;Token_Then=Ab;Token_End=Db;GetFirstToken=function(Eb)return Eb.Token_If end;GetLastToken=function(Eb)return Eb.Token_End end;}end local function qb()local yb=U()local zb,Ab=ib('end')return cb{Type='DoStat';Body=zb;Token_Do=yb;Token_End=Ab;GetFirstToken=function(Bb)return Bb.Token_Do end;GetLastToken=function(Bb)return Bb.Token_End end;}end local function rb()local yb=U()local zb=eb()local Ab=bb('Keyword','do')local Bb,Cb=ib('end')return cb{Type='WhileStat';Condition=zb;Body=Bb;Token_While=yb;Token_Do=Ab;Token_End=Cb;GetFirstToken=function(Db)return Db.Token_While end;GetLastToken=function(Db)return Db.Token_End end;}end local function sb()local yb=U()local zb,Ab=hb()local Bb={}if V().Source=='='then local Cb=U()local Db,Eb=fb()if#Db<2 or#Db>3 then error("expected 2 or 3 values for range bounds")end local Fb=bb('Keyword','do')local Gb,Hb=ib('end')return cb{Type='NumericForStat';VarList=zb;RangeList=Db;Body=Gb;Token_For=yb;Token_VarCommaList=Ab;Token_Equals=Cb;Token_RangeCommaList=Eb;Token_Do=Fb;Token_End=Hb;GetFirstToken=function(Ib)return Ib.Token_For end;GetLastToken=function(Ib)return Ib.Token_End end;}elseif V().Source=='in'then local Cb=U()local Db,Eb=fb()local Fb=bb('Keyword','do')local Gb,Hb=ib('end')return cb{Type='GenericForStat';VarList=zb;GeneratorList=Db;Body=Gb;Token_For=yb;Token_VarCommaList=Ab;Token_In=Cb;Token_GeneratorCommaList=Eb;Token_Do=Fb;Token_End=Hb;GetFirstToken=function(Ib)return Ib.Token_For end;GetLastToken=function(Ib)return Ib.Token_End end;}else error("`=` or in expected")end end local function tb()local yb=U()local zb,Ab=ib('until')local Bb=eb()return cb{Type='RepeatStat';Body=zb;Condition=Bb;Token_Repeat=yb;Token_Until=Ab;GetFirstToken=function(Cb)return Cb.Token_Repeat end;GetLastToken=function(Cb)return Cb.Condition:GetLastToken()end;}end local function ub()local yb=U()if V().Source=='function'then local zb=jb(false)if#zb.NameChain>1 then error(W(zb.Token_NameChainSeparator[1])..": `(` expected.")end return cb{Type='LocalFunctionStat';FunctionStat=zb;Token_Local=yb;GetFirstToken=function(Ab)return Ab.Token_Local end;GetLastToken=function(Ab)return Ab.FunctionStat:GetLastToken()end;}elseif V().Type=='Ident'then local zb,Ab=hb()local Bb,Cb={},{}local Db if V().Source=='='then Db=U()Bb,Cb=fb()end return cb{Type='LocalVarStat';VarList=zb;ExprList=Bb;Token_Local=yb;Token_Equals=Db;Token_VarCommaList=Ab;Token_ExprCommaList=Cb;GetFirstToken=function(Eb)return Eb.Token_Local end;GetLastToken=function(Eb)if#Eb.ExprList>0 then return Eb.ExprList[#Eb.ExprList]:GetLastToken()else return Eb.VarList[#Eb.VarList]end end;}else error("`function` or ident expected")end end local function vb()local yb=U()local zb local Ab if Y()or V().Source==';'then zb={}Ab={}else zb,Ab=fb()end return{Type='ReturnStat';ExprList=zb;Token_Return=yb;Token_CommaList=Ab;GetFirstToken=function(Bb)return Bb.Token_Return end;GetLastToken=function(Bb)if#Bb.ExprList>0 then return Bb.ExprList[#Bb.ExprList]:GetLastToken()else return Bb.Token_Return end end;}end local function wb()local yb=U()return{Type='BreakStat';Token_Break=yb;GetFirstToken=function(zb)return zb.Token_Break end;GetLastToken=function(zb)return zb.Token_Break end;}end local function xb()local yb=V()if yb.Source=='if'then return false,pb()elseif yb.Source=='while'then return false,rb()elseif yb.Source=='do'then return false,qb()elseif yb.Source=='for'then return false,sb()elseif yb.Source=='repeat'then return false,tb()elseif yb.Source=='function'then return false,jb(false)elseif yb.Source=='local'then return false,ub()elseif yb.Source=='return'then return true,vb()elseif yb.Source=='break'then return true,wb()else return false,ob()end end db=function()local yb={}local zb={}local Ab=false while not Ab and not Y()do local Bb Ab,Bb=xb()table.insert(yb,Bb)local Cb=V()if Cb.Type=='Symbol'and Cb.Source==';'then zb[#yb]=U()end end return{Type='StatList';StatementList=yb;SemicolonList=zb;GetFirstToken=function(Bb)if#Bb.StatementList==0 then return nil else return Bb.StatementList[1]:GetFirstToken()end end;GetLastToken=function(Bb)if#Bb.StatementList==0 then return nil elseif Bb.SemicolonList[#Bb.StatementList]then return Bb.SemicolonList[#Bb.StatementList]else return Bb.StatementList[#Bb.StatementList]:GetLastToken()end end;}end return db()end function h(R,S)local T=a{'BinopExpr';'UnopExpr';'NumberLiteral';'StringLiteral';'NilLiteral';'BooleanLiteral';'VargLiteral';'FieldExpr';'IndexExpr';'MethodExpr';'CallExpr';'FunctionLiteral';'VariableExpr';'ParenExpr';'TableLiteral';}local U=a{'StatList';'BreakStat';'ReturnStat';'LocalVarStat';'LocalFunctionStat';'FunctionStat';'RepeatStat';'GenericForStat';'NumericForStat';'WhileStat';'DoStat';'IfStat';'CallExprStat';'AssignmentStat';}for Z,ab in pairs(S)do if not U[Z]and not T[Z]then error("Invalid visitor target: `"..Z.."`")end end local function V(Z)local ab=S[Z.Type]if type(ab)=='function'then return ab(Z)elseif ab and ab.Pre then return ab.Pre(Z)end end local function W(Z)local ab=S[Z.Type]if ab and type(ab)=='table'and ab.Post then return ab.Post(Z)end end local X,Y X=function(Z)if V(Z)then return end if Z.Type=='BinopExpr'then X(Z.Lhs)X(Z.Rhs)elseif Z.Type=='UnopExpr'then X(Z.Rhs)elseif Z.Type=='NumberLiteral'or Z.Type=='StringLiteral'or Z.Type=='NilLiteral'or Z.Type=='BooleanLiteral'or Z.Type=='VargLiteral'then elseif Z.Type=='FieldExpr'then X(Z.Base)elseif Z.Type=='IndexExpr'then X(Z.Base)X(Z.Index)elseif Z.Type=='MethodExpr'or Z.Type=='CallExpr'then X(Z.Base)if Z.FunctionArguments.CallType=='ArgCall'then for ab,bb in pairs(Z.FunctionArguments.ArgList)do X(bb)end elseif Z.FunctionArguments.CallType=='TableCall'then X(Z.FunctionArguments.TableExpr)end elseif Z.Type=='FunctionLiteral'then Y(Z.Body)elseif Z.Type=='VariableExpr'then elseif Z.Type=='ParenExpr'then X(Z.Expression)elseif Z.Type=='TableLiteral'then for ab,bb in pairs(Z.EntryList)do if bb.EntryType=='Field'then X(bb.Value)elseif bb.EntryType=='Index'then X(bb.Index)X(bb.Value)elseif bb.EntryType=='Value'then X(bb.Value)else assert(false,"unreachable")end end else assert(false,"unreachable, type: "..Z.Type..":"..d(Z))end W(Z)end Y=function(Z)if V(Z)then return end if Z.Type=='StatList'then for ab,bb in pairs(Z.StatementList)do Y(bb)end elseif Z.Type=='BreakStat'then elseif Z.Type=='ReturnStat'then for ab,bb in pairs(Z.ExprList)do X(bb)end elseif Z.Type=='LocalVarStat'then if Z.Token_Equals then for ab,bb in pairs(Z.ExprList)do X(bb)end end elseif Z.Type=='LocalFunctionStat'then Y(Z.FunctionStat.Body)elseif Z.Type=='FunctionStat'then Y(Z.Body)elseif Z.Type=='RepeatStat'then Y(Z.Body)X(Z.Condition)elseif Z.Type=='GenericForStat'then for ab,bb in pairs(Z.GeneratorList)do X(bb)end Y(Z.Body)elseif Z.Type=='NumericForStat'then for ab,bb in pairs(Z.RangeList)do X(bb)end Y(Z.Body)elseif Z.Type=='WhileStat'then X(Z.Condition)Y(Z.Body)elseif Z.Type=='DoStat'then Y(Z.Body)elseif Z.Type=='IfStat'then X(Z.Condition)Y(Z.Body)for ab,bb in pairs(Z.ElseClauseList)do if bb.Condition then X(bb.Condition)end Y(bb.Body)end elseif Z.Type=='CallExprStat'then X(Z.Expression)elseif Z.Type=='AssignmentStat'then for ab,bb in pairs(Z.Lhs)do X(bb)end for ab,bb in pairs(Z.Rhs)do X(bb)end else assert(false,"unreachable")end W(Z)end if U[R.Type]then Y(R)else X(R)end end function i(R)local S={}local T=nil local U=0 local function V()U=U+1 return U end local function W()T={ParentScope=T;ChildScopeList={};VariableList={};BeginLocation=V();}if T.ParentScope then T.Depth=T.ParentScope.Depth+1 table.insert(T.ParentScope.ChildScopeList,T)else T.Depth=1 end function T:GetVar(eb)for fb,gb in pairs(self.VariableList)do if gb.Name==eb then return gb end end if self.ParentScope then return self.ParentScope:GetVar(eb)else for fb,gb in pairs(S)do if gb.Name==eb then return gb end end end end end local function X()local eb=T eb.EndLocation=V()for fb,gb in pairs(eb.VariableList)do gb.ScopeEndLocation=eb.EndLocation end T=eb.ParentScope return eb end W()local function Y(eb,fb,gb)assert(gb,"Misisng localInfo")assert(eb,"Missing local var name")local hb={Type='Local';Name=eb;RenameList={fb};AssignedTo=false;Info=gb;UseCount=0;Scope=T;BeginLocation=V();EndLocation=V();ReferenceLocationList={V()};}function hb:Rename(ib)self.Name=ib for jb,kb in pairs(self.RenameList)do kb(ib)end end function hb:Reference()self.UseCount=self.UseCount+1 end table.insert(T.VariableList,hb)return hb end local function Z(eb)for gb,hb in pairs(S)do if hb.Name==eb then return hb end end local fb={Type='Global';Name=eb;RenameList={};AssignedTo=false;UseCount=0;Scope=nil;BeginLocation=V();EndLocation=V();ReferenceLocationList={};}function fb:Rename(gb)self.Name=gb for hb,ib in pairs(self.RenameList)do ib(gb)end end function fb:Reference()self.UseCount=self.UseCount+1 end table.insert(S,fb)return fb end local function ab(eb,fb)assert(eb,"Missing var name")local gb=Z(eb)table.insert(gb.RenameList,fb)return gb end local function bb(eb,fb)for gb=#eb.VariableList,1,-1 do if eb.VariableList[gb].Name==fb then return eb.VariableList[gb]end end if eb.ParentScope then local gb=bb(eb.ParentScope,fb)if gb then return gb end end return nil end local function cb(eb,fb)assert(eb,"Missing var name")local gb=bb(T,eb)if gb then table.insert(gb.RenameList,fb)else gb=ab(eb,fb)end local hb=V()gb.EndLocation=hb table.insert(gb.ReferenceLocationList,gb.EndLocation)return gb end local db={}db.FunctionLiteral={Pre=function(eb)W()for fb,gb in pairs(eb.ArgList)do local hb=Y(gb.Source,function(ib)gb.Source=ib end,{Type='Argument';Index=fb;})end end;Post=function(eb)X()end;}db.VariableExpr=function(eb)eb.Variable=cb(eb.Token.Source,function(fb)eb.Token.Source=fb end)end db.StatList={Pre=function(eb)W()end;Post=function(eb)X()end;}db.LocalVarStat={Post=function(eb)for fb,gb in pairs(eb.VarList)do Y(gb.Source,function(hb)eb.VarList[fb].Source=hb end,{Type='Local';})end end;}db.LocalFunctionStat={Pre=function(eb)Y(eb.FunctionStat.NameChain[1].Source,function(fb)eb.FunctionStat.NameChain[1].Source=fb end,{Type='LocalFunction';})W()for fb,gb in pairs(eb.FunctionStat.ArgList)do Y(gb.Source,function(hb)gb.Source=hb end,{Type='Argument';Index=fb;})end end;Post=function()X()end;}db.FunctionStat={Pre=function(eb)local fb=eb.NameChain local gb if#fb==1 then gb=ab(fb[1].Source,function(hb)fb[1].Source=hb end)else gb=cb(fb[1].Source,function(hb)fb[1].Source=hb end)end gb.AssignedTo=true W()for hb,ib in pairs(eb.ArgList)do Y(ib.Source,function(jb)ib.Source=jb end,{Type='Argument';Index=hb;})end end;Post=function()X()end;}db.GenericForStat={Pre=function(eb)for fb,gb in pairs(eb.GeneratorList)do h(gb,db)end W()for fb,gb in pairs(eb.VarList)do Y(gb.Source,function(hb)gb.Source=hb end,{Type='ForRange';Index=fb;})end h(eb.Body,db)X()return true end;}db.NumericForStat={Pre=function(eb)for fb,gb in pairs(eb.RangeList)do h(gb,db)end W()for fb,gb in pairs(eb.VarList)do Y(gb.Source,function(hb)gb.Source=hb end,{Type='ForRange';Index=fb;})end h(eb.Body,db)X()return true end;}db.AssignmentStat={Post=function(eb)for fb,gb in pairs(eb.Lhs)do if gb.Variable then gb.Variable.AssignedTo=true end end end;}h(R,db)return S,X()end function j(R)local S=""do local T,U local function V(W)if not W.LeadingWhite or not W.Source then error("Bad token: "..d(W))end S=S..W.LeadingWhite S=S..W.Source end U=function(W)if W.Type=='BinopExpr'then U(W.Lhs)V(W.Token_Op)U(W.Rhs)elseif W.Type=='UnopExpr'then V(W.Token_Op)U(W.Rhs)elseif W.Type=='NumberLiteral'or W.Type=='StringLiteral'or W.Type=='NilLiteral'or W.Type=='BooleanLiteral'or W.Type=='VargLiteral'then V(W.Token)elseif W.Type=='FieldExpr'then U(W.Base)V(W.Token_Dot)V(W.Field)elseif W.Type=='IndexExpr'then U(W.Base)V(W.Token_OpenBracket)U(W.Index)V(W.Token_CloseBracket)elseif W.Type=='MethodExpr'or W.Type=='CallExpr'then U(W.Base)if W.Type=='MethodExpr'then V(W.Token_Colon)V(W.Method)end if W.FunctionArguments.CallType=='StringCall'then V(W.FunctionArguments.Token)elseif W.FunctionArguments.CallType=='ArgCall'then V(W.FunctionArguments.Token_OpenParen)for X,Y in pairs(W.FunctionArguments.ArgList)do U(Y)local Z=W.FunctionArguments.Token_CommaList[X]if Z then V(Z)end end V(W.FunctionArguments.Token_CloseParen)elseif W.FunctionArguments.CallType=='TableCall'then U(W.FunctionArguments.TableExpr)end elseif W.Type=='FunctionLiteral'then V(W.Token_Function)V(W.Token_OpenParen)for X,Y in pairs(W.ArgList)do V(Y)local Z=W.Token_ArgCommaList[X]if Z then V(Z)end end V(W.Token_CloseParen)T(W.Body)V(W.Token_End)elseif W.Type=='VariableExpr'then V(W.Token)elseif W.Type=='ParenExpr'then V(W.Token_OpenParen)U(W.Expression)V(W.Token_CloseParen)elseif W.Type=='TableLiteral'then V(W.Token_OpenBrace)for X,Y in pairs(W.EntryList)do if Y.EntryType=='Field'then V(Y.Field)V(Y.Token_Equals)U(Y.Value)elseif Y.EntryType=='Index'then V(Y.Token_OpenBracket)U(Y.Index)V(Y.Token_CloseBracket)V(Y.Token_Equals)U(Y.Value)elseif Y.EntryType=='Value'then U(Y.Value)else assert(false,"unreachable")end local Z=W.Token_SeparatorList[X]if Z then V(Z)end end V(W.Token_CloseBrace)else assert(false,"unreachable, type: "..W.Type..":"..d(W))end end T=function(W)if W.Type=='StatList'then for X,Y in pairs(W.StatementList)do T(Y)if W.SemicolonList[X]then V(W.SemicolonList[X])end end elseif W.Type=='BreakStat'then V(W.Token_Break)elseif W.Type=='ReturnStat'then V(W.Token_Return)for X,Y in pairs(W.ExprList)do U(Y)if W.Token_CommaList[X]then V(W.Token_CommaList[X])end end elseif W.Type=='LocalVarStat'then V(W.Token_Local)for X,Y in pairs(W.VarList)do V(Y)local Z=W.Token_VarCommaList[X]if Z then V(Z)end end if W.Token_Equals then V(W.Token_Equals)for X,Y in pairs(W.ExprList)do U(Y)local Z=W.Token_ExprCommaList[X]if Z then V(Z)end end end elseif W.Type=='LocalFunctionStat'then V(W.Token_Local)V(W.FunctionStat.Token_Function)V(W.FunctionStat.NameChain[1])V(W.FunctionStat.Token_OpenParen)for X,Y in pairs(W.FunctionStat.ArgList)do V(Y)local Z=W.FunctionStat.Token_ArgCommaList[X]if Z then V(Z)end end V(W.FunctionStat.Token_CloseParen)T(W.FunctionStat.Body)V(W.FunctionStat.Token_End)elseif W.Type=='FunctionStat'then V(W.Token_Function)for X,Y in pairs(W.NameChain)do V(Y)local Z=W.Token_NameChainSeparator[X]if Z then V(Z)end end V(W.Token_OpenParen)for X,Y in pairs(W.ArgList)do V(Y)local Z=W.Token_ArgCommaList[X]if Z then V(Z)end end V(W.Token_CloseParen)T(W.Body)V(W.Token_End)elseif W.Type=='RepeatStat'then V(W.Token_Repeat)T(W.Body)V(W.Token_Until)U(W.Condition)elseif W.Type=='GenericForStat'then V(W.Token_For)for X,Y in pairs(W.VarList)do V(Y)local Z=W.Token_VarCommaList[X]if Z then V(Z)end end V(W.Token_In)for X,Y in pairs(W.GeneratorList)do U(Y)local Z=W.Token_GeneratorCommaList[X]if Z then V(Z)end end V(W.Token_Do)T(W.Body)V(W.Token_End)elseif W.Type=='NumericForStat'then V(W.Token_For)for X,Y in pairs(W.VarList)do V(Y)local Z=W.Token_VarCommaList[X]if Z then V(Z)end end V(W.Token_Equals)for X,Y in pairs(W.RangeList)do U(Y)local Z=W.Token_RangeCommaList[X]if Z then V(Z)end end V(W.Token_Do)T(W.Body)V(W.Token_End)elseif W.Type=='WhileStat'then V(W.Token_While)U(W.Condition)V(W.Token_Do)T(W.Body)V(W.Token_End)elseif W.Type=='DoStat'then V(W.Token_Do)T(W.Body)V(W.Token_End)elseif W.Type=='IfStat'then V(W.Token_If)U(W.Condition)V(W.Token_Then)T(W.Body)for X,Y in pairs(W.ElseClauseList)do V(Y.Token)if Y.Condition then U(Y.Condition)V(Y.Token_Then)end T(Y.Body)end V(W.Token_End)elseif W.Type=='CallExprStat'then U(W.Expression)elseif W.Type=='AssignmentStat'then for X,Y in pairs(W.Lhs)do U(Y)local Z=W.Token_LhsSeparatorList[X]if Z then V(Z)end end V(W.Token_Equals)for X,Y in pairs(W.Rhs)do U(Y)local Z=W.Token_RhsSeparatorList[X]if Z then V(Z)end end else assert(false,"unreachable")end end T(R)end return S end local function F(R)local S,T local U=0 local function V(cb)local db='\n'..('\t'):rep(U)if cb.LeadingWhite==''or(cb.LeadingWhite:sub(-#db,-1)~=db)then cb.LeadingWhite=cb.LeadingWhite:gsub("\n?[\t ]*$","")cb.LeadingWhite=cb.LeadingWhite..db end end local function W()U=U+1 end local function X()U=U-1 assert(U>=0,"Undented too far")end local function Y(cb)if#cb.LeadingWhite>0 then return cb.LeadingWhite:sub(1,1)else return cb.Source:sub(1,1)end end local function Z(cb)if not p[Y(cb)]then cb.LeadingWhite=' '..cb.LeadingWhite end end local function ab(cb)Z(cb:GetFirstToken())end local function bb(cb,db,eb)W()S(db)X()V(eb)end T=function(cb)if cb.Type=='BinopExpr'then T(cb.Lhs)T(cb.Rhs)if cb.Token_Op.Source=='..'then else ab(cb.Rhs)Z(cb.Token_Op)end elseif cb.Type=='UnopExpr'then T(cb.Rhs)elseif cb.Type=='NumberLiteral'or cb.Type=='StringLiteral'or cb.Type=='NilLiteral'or cb.Type=='BooleanLiteral'or cb.Type=='VargLiteral'then elseif cb.Type=='FieldExpr'then T(cb.Base)elseif cb.Type=='IndexExpr'then T(cb.Base)T(cb.Index)elseif cb.Type=='MethodExpr'or cb.Type=='CallExpr'then T(cb.Base)if cb.Type=='MethodExpr'then end if cb.FunctionArguments.CallType=='StringCall'then elseif cb.FunctionArguments.CallType=='ArgCall'then for db,eb in pairs(cb.FunctionArguments.ArgList)do T(eb)if db>1 then ab(eb)end local fb=cb.FunctionArguments.Token_CommaList[db]if fb then end end elseif cb.FunctionArguments.CallType=='TableCall'then T(cb.FunctionArguments.TableExpr)end elseif cb.Type=='FunctionLiteral'then for db,eb in pairs(cb.ArgList)do if db>1 then Z(eb)end local fb=cb.Token_ArgCommaList[db]if fb then end end bb(cb.Token_CloseParen,cb.Body,cb.Token_End)elseif cb.Type=='VariableExpr'then elseif cb.Type=='ParenExpr'then T(cb.Expression)elseif cb.Type=='TableLiteral'then if#cb.EntryList==0 then else W()for db,eb in pairs(cb.EntryList)do if eb.EntryType=='Field'then V(eb.Field)Z(eb.Token_Equals)T(eb.Value)ab(eb.Value)elseif eb.EntryType=='Index'then V(eb.Token_OpenBracket)T(eb.Index)Z(eb.Token_Equals)T(eb.Value)ab(eb.Value)elseif eb.EntryType=='Value'then T(eb.Value)V(eb.Value:GetFirstToken())else assert(false,"unreachable")end local fb=cb.Token_SeparatorList[db]if fb then end end X()V(cb.Token_CloseBrace)end else assert(false,"unreachable, type: "..cb.Type..":"..d(cb))end end S=function(cb)if cb.Type=='StatList'then for db,eb in pairs(cb.StatementList)do S(eb)V(eb:GetFirstToken())end elseif cb.Type=='BreakStat'then elseif cb.Type=='ReturnStat'then for db,eb in pairs(cb.ExprList)do T(eb)ab(eb)if cb.Token_CommaList[db]then end end elseif cb.Type=='LocalVarStat'then for db,eb in pairs(cb.VarList)do Z(eb)local fb=cb.Token_VarCommaList[db]if fb then end end if cb.Token_Equals then Z(cb.Token_Equals)for db,eb in pairs(cb.ExprList)do T(eb)ab(eb)local fb=cb.Token_ExprCommaList[db]if fb then end end end elseif cb.Type=='LocalFunctionStat'then Z(cb.FunctionStat.Token_Function)Z(cb.FunctionStat.NameChain[1])for db,eb in pairs(cb.FunctionStat.ArgList)do if db>1 then Z(eb)end local fb=cb.FunctionStat.Token_ArgCommaList[db]if fb then end end bb(cb.FunctionStat.Token_CloseParen,cb.FunctionStat.Body,cb.FunctionStat.Token_End)elseif cb.Type=='FunctionStat'then for db,eb in pairs(cb.NameChain)do if db==1 then Z(eb)end local fb=cb.Token_NameChainSeparator[db]if fb then end end for db,eb in pairs(cb.ArgList)do if db>1 then Z(eb)end local fb=cb.Token_ArgCommaList[db]if fb then end end bb(cb.Token_CloseParen,cb.Body,cb.Token_End)elseif cb.Type=='RepeatStat'then bb(cb.Token_Repeat,cb.Body,cb.Token_Until)T(cb.Condition)ab(cb.Condition)elseif cb.Type=='GenericForStat'then for db,eb in pairs(cb.VarList)do Z(eb)local fb=cb.Token_VarCommaList[db]if fb then end end Z(cb.Token_In)for db,eb in pairs(cb.GeneratorList)do T(eb)ab(eb)local fb=cb.Token_GeneratorCommaList[db]if fb then end end Z(cb.Token_Do)bb(cb.Token_Do,cb.Body,cb.Token_End)elseif cb.Type=='NumericForStat'then for db,eb in pairs(cb.VarList)do Z(eb)local fb=cb.Token_VarCommaList[db]if fb then end end Z(cb.Token_Equals)for db,eb in pairs(cb.RangeList)do T(eb)ab(eb)local fb=cb.Token_RangeCommaList[db]if fb then end end Z(cb.Token_Do)bb(cb.Token_Do,cb.Body,cb.Token_End)elseif cb.Type=='WhileStat'then T(cb.Condition)ab(cb.Condition)Z(cb.Token_Do)bb(cb.Token_Do,cb.Body,cb.Token_End)elseif cb.Type=='DoStat'then bb(cb.Token_Do,cb.Body,cb.Token_End)elseif cb.Type=='IfStat'then T(cb.Condition)ab(cb.Condition)Z(cb.Token_Then)local db=cb.Token_Then local eb=cb.Body for fb,gb in pairs(cb.ElseClauseList)do bb(db,eb,gb.Token)db=gb.Token if gb.Condition then T(gb.Condition)ab(gb.Condition)Z(gb.Token_Then)db=gb.Token_Then end eb=gb.Body end bb(db,eb,cb.Token_End)elseif cb.Type=='CallExprStat'then T(cb.Expression)elseif cb.Type=='AssignmentStat'then for db,eb in pairs(cb.Lhs)do T(eb)if db>1 then ab(eb)end local fb=cb.Token_LhsSeparatorList[db]if fb then end end Z(cb.Token_Equals)for db,eb in pairs(cb.Rhs)do T(eb)ab(eb)local fb=cb.Token_RhsSeparatorList[db]if fb then end end else assert(false,"unreachable")end end S(R)end local function G(R)local S,T local function U(X)X.LeadingWhite=''end local function V(X,Y)U(Y)local Z=X.Source:sub(-1,-1)local ab=Y.Source:sub(1,1)if(Z=='-'and ab=='-')or(t[Z]and t[ab])then Y.LeadingWhite=' 'else Y.LeadingWhite=''end end local function W(X,Y,Z)S(Y)U(Z)local ab=Y:GetFirstToken()local bb=Y:GetLastToken()if ab then V(X,ab)V(bb,Z)else V(X,Z)end end T=function(X)if X.Type=='BinopExpr'then T(X.Lhs)U(X.Token_Op)T(X.Rhs)V(X.Token_Op,X.Rhs:GetFirstToken())V(X.Lhs:GetLastToken(),X.Token_Op)elseif X.Type=='UnopExpr'then U(X.Token_Op)T(X.Rhs)V(X.Token_Op,X.Rhs:GetFirstToken())elseif X.Type=='NumberLiteral'or X.Type=='StringLiteral'or X.Type=='NilLiteral'or X.Type=='BooleanLiteral'or X.Type=='VargLiteral'then U(X.Token)elseif X.Type=='FieldExpr'then T(X.Base)U(X.Token_Dot)U(X.Field)elseif X.Type=='IndexExpr'then T(X.Base)U(X.Token_OpenBracket)T(X.Index)U(X.Token_CloseBracket)elseif X.Type=='MethodExpr'or X.Type=='CallExpr'then T(X.Base)if X.Type=='MethodExpr'then U(X.Token_Colon)U(X.Method)end if X.FunctionArguments.CallType=='StringCall'then U(X.FunctionArguments.Token)elseif X.FunctionArguments.CallType=='ArgCall'then U(X.FunctionArguments.Token_OpenParen)for Y,Z in pairs(X.FunctionArguments.ArgList)do T(Z)local ab=X.FunctionArguments.Token_CommaList[Y]if ab then U(ab)end end U(X.FunctionArguments.Token_CloseParen)elseif X.FunctionArguments.CallType=='TableCall'then T(X.FunctionArguments.TableExpr)end elseif X.Type=='FunctionLiteral'then U(X.Token_Function)U(X.Token_OpenParen)for Y,Z in pairs(X.ArgList)do U(Z)local ab=X.Token_ArgCommaList[Y]if ab then U(ab)end end U(X.Token_CloseParen)W(X.Token_CloseParen,X.Body,X.Token_End)elseif X.Type=='VariableExpr'then U(X.Token)elseif X.Type=='ParenExpr'then U(X.Token_OpenParen)T(X.Expression)U(X.Token_CloseParen)elseif X.Type=='TableLiteral'then U(X.Token_OpenBrace)for Y,Z in pairs(X.EntryList)do if Z.EntryType=='Field'then U(Z.Field)U(Z.Token_Equals)T(Z.Value)elseif Z.EntryType=='Index'then U(Z.Token_OpenBracket)T(Z.Index)U(Z.Token_CloseBracket)U(Z.Token_Equals)T(Z.Value)elseif Z.EntryType=='Value'then T(Z.Value)else assert(false,"unreachable")end local ab=X.Token_SeparatorList[Y]if ab then U(ab)end end U(X.Token_CloseBrace)else assert(false,"unreachable, type: "..X.Type..":"..d(X))end end S=function(X)if X.Type=='StatList'then for Y=1,#X.StatementList do local Z=X.StatementList[Y]S(Z)U(Z:GetFirstToken())local ab=X.StatementList[Y-1]if ab then if X.SemicolonList[Y-1]and(ab:GetLastToken().Source~=')'or Z:GetFirstToken().Source~=')')then X.SemicolonList[Y-1]=nil end if not X.SemicolonList[Y-1]then V(ab:GetLastToken(),Z:GetFirstToken())end end end X.SemicolonList[#X.StatementList]=nil if#X.StatementList>0 then U(X.StatementList[1]:GetFirstToken())end elseif X.Type=='BreakStat'then U(X.Token_Break)elseif X.Type=='ReturnStat'then U(X.Token_Return)for Y,Z in pairs(X.ExprList)do T(Z)if X.Token_CommaList[Y]then U(X.Token_CommaList[Y])end end if#X.ExprList>0 then V(X.Token_Return,X.ExprList[1]:GetFirstToken())end elseif X.Type=='LocalVarStat'then U(X.Token_Local)for Y,Z in pairs(X.VarList)do if Y==1 then V(X.Token_Local,Z)else U(Z)end local ab=X.Token_VarCommaList[Y]if ab then U(ab)end end if X.Token_Equals then U(X.Token_Equals)for Y,Z in pairs(X.ExprList)do T(Z)local ab=X.Token_ExprCommaList[Y]if ab then U(ab)end end end elseif X.Type=='LocalFunctionStat'then U(X.Token_Local)V(X.Token_Local,X.FunctionStat.Token_Function)V(X.FunctionStat.Token_Function,X.FunctionStat.NameChain[1])V(X.FunctionStat.NameChain[1],X.FunctionStat.Token_OpenParen)for Y,Z in pairs(X.FunctionStat.ArgList)do U(Z)local ab=X.FunctionStat.Token_ArgCommaList[Y]if ab then U(ab)end end U(X.FunctionStat.Token_CloseParen)W(X.FunctionStat.Token_CloseParen,X.FunctionStat.Body,X.FunctionStat.Token_End)elseif X.Type=='FunctionStat'then U(X.Token_Function)for Y,Z in pairs(X.NameChain)do if Y==1 then V(X.Token_Function,Z)else U(Z)end local ab=X.Token_NameChainSeparator[Y]if ab then U(ab)end end U(X.Token_OpenParen)for Y,Z in pairs(X.ArgList)do U(Z)local ab=X.Token_ArgCommaList[Y]if ab then U(ab)end end U(X.Token_CloseParen)W(X.Token_CloseParen,X.Body,X.Token_End)elseif X.Type=='RepeatStat'then U(X.Token_Repeat)W(X.Token_Repeat,X.Body,X.Token_Until)T(X.Condition)V(X.Token_Until,X.Condition:GetFirstToken())elseif X.Type=='GenericForStat'then U(X.Token_For)for Y,Z in pairs(X.VarList)do if Y==1 then V(X.Token_For,Z)else U(Z)end local ab=X.Token_VarCommaList[Y]if ab then U(ab)end end V(X.VarList[#X.VarList],X.Token_In)for Y,Z in pairs(X.GeneratorList)do T(Z)if Y==1 then V(X.Token_In,Z:GetFirstToken())end local ab=X.Token_GeneratorCommaList[Y]if ab then U(ab)end end V(X.GeneratorList[#X.GeneratorList]:GetLastToken(),X.Token_Do)W(X.Token_Do,X.Body,X.Token_End)elseif X.Type=='NumericForStat'then U(X.Token_For)for Y,Z in pairs(X.VarList)do if Y==1 then V(X.Token_For,Z)else U(Z)end local ab=X.Token_VarCommaList[Y]if ab then U(ab)end end V(X.VarList[#X.VarList],X.Token_Equals)for Y,Z in pairs(X.RangeList)do T(Z)if Y==1 then V(X.Token_Equals,Z:GetFirstToken())end local ab=X.Token_RangeCommaList[Y]if ab then U(ab)end end V(X.RangeList[#X.RangeList]:GetLastToken(),X.Token_Do)W(X.Token_Do,X.Body,X.Token_End)elseif X.Type=='WhileStat'then U(X.Token_While)T(X.Condition)U(X.Token_Do)V(X.Token_While,X.Condition:GetFirstToken())V(X.Condition:GetLastToken(),X.Token_Do)W(X.Token_Do,X.Body,X.Token_End)elseif X.Type=='DoStat'then U(X.Token_Do)U(X.Token_End)W(X.Token_Do,X.Body,X.Token_End)elseif X.Type=='IfStat'then U(X.Token_If)T(X.Condition)V(X.Token_If,X.Condition:GetFirstToken())V(X.Condition:GetLastToken(),X.Token_Then)local Y=X.Token_Then local Z=X.Body for ab,bb in pairs(X.ElseClauseList)do W(Y,Z,bb.Token)Y=bb.Token if bb.Condition then T(bb.Condition)V(bb.Token,bb.Condition:GetFirstToken())V(bb.Condition:GetLastToken(),bb.Token_Then)Y=bb.Token_Then end S(bb.Body)Z=bb.Body end W(Y,Z,X.Token_End)elseif X.Type=='CallExprStat'then T(X.Expression)elseif X.Type=='AssignmentStat'then for Y,Z in pairs(X.Lhs)do T(Z)local ab=X.Token_LhsSeparatorList[Y]if ab then U(ab)end end U(X.Token_Equals)for Y,Z in pairs(X.Rhs)do T(Z)local ab=X.Token_RhsSeparatorList[Y]if ab then U(ab)end end else assert(false,"unreachable")end end S(R)end local H=0 local I={}for R=('a'):byte(),('z'):byte()do table.insert(I,string.char(R))end for R=('A'):byte(),('Z'):byte()do table.insert(I,string.char(R))end for R=('0'):byte(),('9'):byte()do table.insert(I,string.char(R))end table.insert(I,'_')local J={}for R=('a'):byte(),('z'):byte()do table.insert(J,string.char(R))end for R=('A'):byte(),('Z'):byte()do table.insert(J,string.char(R))end local function K(R)local S=''local T=R%#J R=(R-T)/#J S=S..J[T+1]while R>0 do local U=R%#I R=(R-U)/#I S=S..I[U+1]end return S end local function L()local R=H H=H+1 return K(R)end local function M()local R=''repeat R=L()until not y[R]return R end local function N(R,S)local T={}local U=0 for Y,Z in pairs(R)do if Z.AssignedTo then Z:Rename('_TMP_'..U..'_')U=U+1 else T[Z.Name]=true end end local function V(Y)for Z,ab in pairs(Y.VariableList)do ab:Rename('_TMP_'..U..'_')U=U+1 end for Z,ab in pairs(Y.ChildScopeList)do V(ab)end end local W=0 for Y,Z in pairs(R)do if Z.AssignedTo then local ab=''repeat ab=K(W)W=W+1 until not y[ab]and not T[ab]Z:Rename(ab)end end S.FirstFreeName=W local function X(Y)for Z,ab in pairs(Y.VariableList)do local bb=''repeat bb=K(Y.FirstFreeName)Y.FirstFreeName=Y.FirstFreeName+1 until not y[bb]and not T[bb]ab:Rename(bb)end for Z,ab in pairs(Y.ChildScopeList)do ab.FirstFreeName=Y.FirstFreeName X(ab)end end X(S)end local function O(R,S)local T={}for Z,ab in pairs(y)do T[Z]=true end local U={}local V={}do for ab,bb in pairs(R)do if bb.AssignedTo then table.insert(U,bb)else T[bb.Name]=true end end local function Z(ab)for bb,cb in pairs(ab.VariableList)do table.insert(U,cb)table.insert(V,cb)end for bb,cb in pairs(ab.ChildScopeList)do Z(cb)end end Z(S)end for Z,ab in pairs(U)do ab.UsedNameArray={}end table.sort(U,function(Z,ab)return#Z.RenameList<#ab.RenameList end)local W=0 local X={}local function Y(Z)local ab=X[Z]if not ab then repeat ab=K(W)W=W+1 until not T[ab]X[Z]=ab end return ab end for Z,ab in pairs(U)do ab.Renamed=true local bb=1 while ab.UsedNameArray[bb]do bb=bb+1 end ab:Rename(Y(bb))if ab.Scope then for cb,db in pairs(U)do if not db.Renamed then if not db.Scope or db.Scope.Depth<ab.Scope.Depth then for eb,fb in pairs(db.ReferenceLocationList)do if fb>=ab.BeginLocation and fb<=ab.ScopeEndLocation then db.UsedNameArray[bb]=true break end end elseif db.Scope.Depth>ab.Scope.Depth then for eb,fb in pairs(ab.ReferenceLocationList)do if fb>=db.BeginLocation and fb<=db.ScopeEndLocation then db.UsedNameArray[bb]=true break end end else if ab.BeginLocation<db.EndLocation and ab.EndLocation>db.BeginLocation then db.UsedNameArray[bb]=true end end end end else for cb,db in pairs(U)do if not db.Renamed then if db.Type=='Global'then db.UsedNameArray[bb]=true elseif db.Type=='Local'then for eb,fb in pairs(ab.ReferenceLocationList)do if fb>=db.BeginLocation and fb<=db.ScopeEndLocation then db.UsedNameArray[bb]=true break end end else assert(false,"unreachable")end end end end end end local function P(R,S)local T={}for Y,Z in pairs(R)do if not Z.AssignedTo then T[Z.Name]=true end end local U=1 local V=1 local function W(Y,Z)Y.Name=Z for ab,bb in pairs(Y.RenameList)do bb(Z)end end for Y,Z in pairs(R)do if Z.AssignedTo then W(Z,'G_'..V)V=V+1 end end local function X(Y)for Z,ab in pairs(Y.VariableList)do local bb='L_'..U..'_'if ab.Info.Type=='Argument'then bb=bb..'arg'..ab.Info.Index elseif ab.Info.Type=='LocalFunction'then bb=bb..'func'elseif ab.Info.Type=='ForRange'then bb=bb..'forvar'..ab.Info.Index end W(ab,bb)U=U+1 end for Z,ab in pairs(Y.ChildScopeList)do X(ab)end end X(S)end local function Q()error("\nusage: minify <file> or unminify <file>\n".."  The modified code will be printed to the stdout, pipe it to a file, the\n".."  lua interpreter, or something else as desired EG:\n\n".."        lua minify.lua minify input.lua > output.lua\n\n".."  * minify will minify the code in the file.\n".."  * unminify will beautify the code and replace the variable names with easily\n".."    find-replacable ones to aide in reverse engineering minified code.\n",0)end k={["CreateLuaParser"]=f,["AddVariableInfo"]=i,["MinifyVariables"]=N,["StripAst"]=G,["BeautifyVariables"]=P,["FormatAst"]=F,["PrintAst"]=j,}end local l={}function l.minify(p)local q=k["CreateLuaParser"](p)local r,s=k["AddVariableInfo"](q)k["MinifyVariables"](r,s)k["StripAst"](q)local t=k["PrintAst"](q)print("Finished minifying!")return t end function l.unminify(p)local q=k["CreateLuaParser"](p)local r,s=k["AddVariableInfo"](q)k["BeautifyVariables"](r,s)k["FormatAst"](q)return k["PrintAst"](q)end local function m(p)local q=io.open(p,'r')if not q then error("Could not open the input file `"..p.."`",0)end local r=q:read('*all')q:close()return r end local function n(p,q)local r=io.open(p,'w')if not r then error("Could not open the input file `"..p.."`",0)end local s=r:write(q)r:close()return s end local function o(p,q,r)local s=m(q)local t=p(s)if r~=nil then n(r,t)end return t end function l.minifyFile(p,q)local r=m(p)local s=l.minify(r)print("Finished minfying file!")if q~=nil then print("Writing mini-output to file")n(q,s)end print("DONE")return s end function l.unminifyFile(p,q)local r=m(p)local s=l.minify(r)if q~=nil then n(q,s)end return s end return l